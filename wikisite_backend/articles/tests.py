import pytest
from django.contrib.auth.models import User
from rest_framework import status
from rest_framework.test import APITestCase

from articles.models import Article, ArticleRevision


def _create_article(name, content):
    """
    Create an article in the DB w/ the given title and content
    """
    article = Article(name=name)
    article.save()
    revision = ArticleRevision(article=article, content=content)
    revision.save()
    return article


@pytest.mark.django_db
class ArticleIndexTests(APITestCase):
    def test_one_article(self):
        """
        Ensure that the articles api returns as expected w/ one article.
        """
        _create_article(name="Test Article", content="This is a test article")

        response = self.client.get("/api/articles/")
        assert response.status_code == status.HTTP_200_OK
        assert len(response.data) == 1

        response_article = response.data[0]
        assert response_article["name"] == "Test Article"
        assert "creation_date" in response_article

        # Content is too long to put in the index view
        assert "content" not in response_article

    def test_order_by_creation(self):
        """
        If there are multiple articles, they should be ordered by creation time.
        """
        _create_article(name="Test Article 1", content="This is a test article")
        _create_article(name="Test Article 2", content="This is a test article")

        response = self.client.get("/api/articles/")
        assert response.status_code == status.HTTP_200_OK
        assert len(response.data) == 2

        # First article should be the one that was created second
        first_user = response.data[0]
        assert first_user["name"] == "Test Article 2"

        second_user = response.data[1]
        assert second_user["name"] == "Test Article 1"


@pytest.mark.django_db
class ArticleViewTest(APITestCase):
    def test_view_article(self):
        """
        Ensure that the article view works as expected.
        """
        _create_article(name="Test Article", content="This is a test article")

        response = self.client.get("/api/articles/1/")
        assert response.status_code == status.HTTP_200_OK

        response_article = response.data
        assert response_article["name"] == "Test Article"
        assert response_article["content"] == "This is a test article"
        assert "creation_date" in response_article


def _get_article(name):
    """
    Get an article from the DB by name
    """
    article = Article.objects.get(name=name)
    assert article is not None
    return {"name": article.name, "content": article.latest_revision.content}


@pytest.mark.django_db
class ArticleCreationTest(APITestCase):
    def setUp(self):
        self.user = User.objects.create_user(
            username="testUser", password="@dequatePassword1"
        )
        self.client.force_login(user=self.user)

    def test_create_article(self):
        """
        Test the happy path of creating an article.
        """
        article_data = {"name": "Test Article", "content": "This is a test article"}
        response = self.client.post("/api/articles/", data=article_data, format="json")

        assert response.status_code == status.HTTP_201_CREATED

        # Make sure the article was created in the DB
        article = _get_article(article_data["name"])
        assert article["content"] == article_data["content"]

    def test_creation_date_read_only(self):
        """
        Ensure that specifying the creation date of an article is not allowed.
        (it should be autogenerated by the server instead)
        """
        article_data = {
            "name": "Test Article",
            "content": "This is a test article",
            "creation_date": "2018-10-25T02:23:59.962974Z",
        }
        self.client.post("/api/articles/", data=article_data, format="json")

        # Make sure the specified creation date was not used
        # (the datetime should be autoset to the current datetime)
        article = Article.objects.get(name=article_data["name"])
        assert article.creation_date.isoformat() != article_data["creation_date"]

    def test_unauthenticated(self):
        """
        Unauthenticated users should be unable to post articles
        """
        article_data = {"name": "Test Article", "content": "This is a test article"}
        self.client.logout()
        response = self.client.post("/api/articles/", data=article_data, format="json")

        assert (
            response.status_code == status.HTTP_401_UNAUTHORIZED or
            response.status_code == status.HTTP_403_FORBIDDEN
        )


@pytest.mark.django_db
class ArticleUpdateTest(APITestCase):
    def setUp(self):
        self.user = User.objects.create_user(
            username="testUser", password="@dequatePassword1"
        )
        self.client.force_login(user=self.user)

        # Create an article that we're gonna update within the tests
        self.article = _create_article(name="Test Article", content="Initial content")
        self.article_url = "/api/articles/%d/" % (self.article.id,)

    def test_update_article(self):
        """
        Test the happy path of updating an article.
        """
        # We use a different user for the modification so that
        # we can tell it was made properly
        self.user = User.objects.create_user(
            username="testUser2", password="@dequatePassword1"
        )
        self.client.force_login(user=self.user)

        article_data = {"name": self.article.name, "content": "This is a test article"}
        response = self.client.put(self.article_url, data=article_data, format="json")

        assert response.status_code == status.HTTP_200_OK

        # Make sure the article was updated in the DB
        db_article = _get_article(self.article.name)
        assert db_article["content"] == article_data["content"]

        # Make sure that the new revision shows up on the bottom
        # (use the user to determine the new revision)
        assert response.data["revisions"][1]["author"]["username"] == "testUser2"

        # Now fetch the revision and make sure that works, just for fun
        revision_response = self.client.get(
            response.data["revisions"][1]["url"],
            data=article_data, format="json"
        )
        assert revision_response.status_code == status.HTTP_200_OK
        assert revision_response.data["content"] == article_data["content"]

    def test_update_article_locked(self):
        """
        Test that updating a locked article fails
        """
        self.article.locked = True
        self.article.save()

        # We use a different user for the modification so that
        # we can tell it was made properly
        self.user = User.objects.create_user(
            username="testUser2", password="@dequatePassword1"
        )
        self.client.force_login(user=self.user)

        article_data = {"name": self.article.name, "content": "This is a test article"}
        response = self.client.put(self.article_url, data=article_data, format="json")

        assert response.status_code != status.HTTP_200_OK
